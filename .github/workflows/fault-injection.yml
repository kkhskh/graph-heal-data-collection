name: Fault Injection Data Collection

on:
  workflow_dispatch:
    inputs:
      hours:
        description: 'Hours to run'
        required: true
        default: '20'  # 20 minutes per experiment
      services:
        description: 'Services to inject faults into (space-separated)'
        required: true
        default: 'service_a service_b service_c service_d'

jobs:
  fault-injection:
    runs-on: ubuntu-latest
    timeout-minutes: 700  # ~11.5 hours max per job (buffer for 10-hour runs)
    strategy:
      matrix:
        batch: [0, 1, 2, 3]  # Split into 4 parallel jobs
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt

    - name: Set up Docker
      uses: docker/setup-buildx-action@v3
      with:
        install: true

    - name: Start Docker daemon
      run: |
        sudo systemctl start docker || true
        sudo systemctl status docker
        sudo chmod 666 /var/run/docker.sock

    - name: Install Docker Compose
      run: |
        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose

    - name: Build all services (force no-cache)
      run: |
        docker-compose build --no-cache

    - name: Start services
      run: |
        docker-compose up -d
        sleep 30

    - name: Show container status
      run: |
        docker-compose ps
        docker-compose logs service-a || true
        docker-compose logs service-b || true
        docker-compose logs service-c || true
        docker-compose logs service-d || true

    - name: Wait for all services to be healthy
      run: |
        for port in 5001 5002 5003 5004; do
          echo "Waiting for service on port $port to be ready..."
          timeout=30
          while [ $timeout -gt 0 ] && ! curl -sf http://localhost:$port/metrics; do 
            sleep 2
            timeout=$((timeout-2))
          done
          if [ $timeout -le 0 ]; then
            echo "Service on port $port failed to start within 30 seconds"
            exit 1
          fi
          echo "Service on port $port is ready."
        done
        echo "All services are healthy."
    
    - name: Start monitoring
      run: |
        python scripts/run_monitoring.py &
        sleep 10
    
    - name: Create output directories
      run: |
        mkdir -p data/fault_injection
        mkdir -p results
        ls -la data/
    
    - name: Test experiment setup (fallback)
      run: |
        # Create and run test script
        cat > test_runner.py << 'EOF'
        #!/usr/bin/env python3
        import sys
        import os
        import json
        import csv
        from datetime import datetime
        
        def create_test_files():
            os.makedirs('data/fault_injection', exist_ok=True)
            os.makedirs('results', exist_ok=True)
            
            # Create fault_labels.csv
            with open('fault_labels.csv', 'w', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=['timestamp', 'service', 'fault_type', 'duration'])
                writer.writeheader()
                writer.writerow({
                    'timestamp': datetime.now().isoformat(),
                    'service': 'service-a',
                    'fault_type': 'cpu',
                    'duration': 60
                })
            
            # Create test result
            test_result = {
                'experiment_id': 0,
                'batch': ${{ matrix.batch }},
                'timestamp': datetime.now().isoformat(),
                'status': 'test_run'
            }
            
            with open('data/fault_injection/test_result.json', 'w') as f:
                json.dump(test_result, f, indent=2)
            
            print("Test files created successfully")
        
        if __name__ == "__main__":
            create_test_files()
        EOF
        
        python test_runner.py
    
    - name: Run fault injection with detailed logging
      continue-on-error: true
      run: |
        START_ID=$(( ${{ matrix.batch }} * 25 ))
        END_ID=$(( START_ID + 24 ))
        echo "Running experiments from $START_ID to $END_ID"
        DURATION=$(echo "${{ github.event.inputs.hours }} * 60" | bc -l | cut -d'.' -f1)
        echo "Duration per experiment: $DURATION seconds ($(echo "$DURATION / 60" | bc -l) minutes)"
        
        # Ensure duration is at least 10 seconds
        if [ "$DURATION" -lt 10 ]; then
          DURATION=10
          echo "Duration adjusted to minimum 10 seconds"
        fi
        
        # Run with verbose output and error handling
        timeout 300 python scripts/run_experiments.py \
          --start-id $START_ID \
          --end-id $END_ID \
          --duration $DURATION \
          --services "${{ github.event.inputs.services }}" \
          2>&1 | tee experiment_output.log || echo "Experiment timed out or failed"
        
        # Check if experiment completed
        echo "Experiment exit code: $?"
    
    - name: Debug - Check for created files
      if: always()
      run: |
        echo "=== Current directory structure ==="
        find . -name "*.csv" -o -name "*.json" -o -path "*/data/*" -o -path "*/results/*" | head -20
        
        echo "=== Contents of data directory ==="
        ls -la data/ || echo "No data directory"
        
        echo "=== Contents of data/fault_injection directory ==="
        ls -la data/fault_injection/ || echo "No data/fault_injection directory"
        
        echo "=== Contents of results directory ==="
        ls -la results/ || echo "No results directory"
        
        echo "=== Looking for fault_labels.csv ==="
        find . -name "fault_labels.csv" -ls || echo "No fault_labels.csv found"
        
        echo "=== Contents of experiment_output.log ==="
        tail -50 experiment_output.log || echo "No experiment output log"
    
    - name: Create minimal test files if none exist
      if: always()
      run: |
        # Create minimal files to ensure upload works
        if [ ! -f "fault_labels.csv" ]; then
          echo "timestamp,service,fault_type,duration" > fault_labels.csv
          echo "$(date -Iseconds),test_service,cpu,60" >> fault_labels.csv
          echo "Created minimal fault_labels.csv"
        fi
        
        if [ ! -d "data/fault_injection" ] || [ -z "$(ls -A data/fault_injection 2>/dev/null)" ]; then
          mkdir -p data/fault_injection
          echo '{"test": "data", "batch": ${{ matrix.batch }}}' > data/fault_injection/test_output.json
          echo "Created minimal test output"
        fi
        
        # Show final file structure
        echo "=== Final file structure for upload ==="
        ls -la fault_labels.csv data/fault_injection/ || true
    
    - name: Upload results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: fault-injection-results-batch-${{ matrix.batch }}
        path: |
          data/
          fault_labels.csv
          results/
          experiment_output.log
        retention-days: 30
    
    - name: Upload logs separately (fallback)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: debug-logs-batch-${{ matrix.batch }}
        path: |
          experiment_output.log
          *.log
        retention-days: 7
    
    - name: Clean up
      if: always()
      run: |
        docker-compose down
        docker system prune -f 

    - name: Docker Info (Debug)
      if: always()
      run: |
        docker info || true
        echo "DOCKER_HOST=$DOCKER_HOST"
        ls -l /var/run/docker.sock || true 

    - name: List running containers (Debug)
      if: always()
      run: docker ps -a
